<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TrailMate - 채팅</title>
    <link rel="stylesheet" href="/static/base.css">
    <link rel="stylesheet" href="/static/chat.css">
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://apis.openapi.sk.com/tmap/jsv2?version=1&appKey={{ tmap_api_key }}"></script>
</head>
<body>
    <div class="chat-container">
        <aside class="sidebar">
            <div class="sidebar-header">
                <button class="new-chat-btn">+ 새 대화 시작</button>
                <button onclick='location.href="/"' class="back-to-home-btn">홈으로 돌아가기</button>
            </div>
            <div class="sidebar-content">
                <p>최근대화</p>
            </div>
            <div class="sidebar-footer">
                <a href="#">설정</a>
                <a href="#">도움말</a>
            </div>
        </aside>

        <main class="chat-area">
            <header class="chat-header">
                <h2><img src="/static/squirrel.png" width="30px" height="30px"> 캠토리</h2>
                <p>캠핑 전문가 AI 어시스턴트</p>
            </header>
            <div id="weather-info"></div>
            <div class="messages">
                <div class="message bot">
                    <p>안녕하세요! 저는 캠토리입니다. 캠핑에 관한 모든 질문에 답해드릴게요! 어떤 도움이 필요하신가요? 😊</p>
                </div>
            </div>
            <footer class="chat-footer">
                <form id="chat-form" class="chat-input-form">
                    <input type="text" id="chat-input" placeholder="궁금한 점을 물어보세요...">
                    <button type="submit">전송</button>
                </form>
            </footer>
        </main>

        <aside class="map-and-list-container">
            <div class="map-container">
                <div id="map_div" style="width: 100%; height: 400px;"></div>
            </div>
            <div id="route-list-container">
                <ul id="route-list"></ul>
            </div>
        </aside>
    </div>

    <script src="/static/script.js"></script>
    <script>
        let userLocation;
        let map;
        let markers = [];
        let polylines = [];
        let recommendedLocations = []; // 추천 장소 목록 저장

        function getWeatherAndDisplay(lat, lon) {
            const apiKey = '{{ openweathermap_api_key }}'; // Loaded from .env via Flask
            const weatherUrl = `https://api.openweathermap.org/data/2.5/forecast?lat=${lat}&lon=${lon}&appid=${apiKey}&units=metric&lang=kr`;

            fetch(weatherUrl)
                .then(response => response.json())
                .then(data => {
                    const weatherInfoDiv = document.getElementById('weather-info');
                    if (data.list && data.list.length > 0) {
                        let forecastHtml = `<h3>${data["city"]["name"]} 날씨 예보</h3><div class="weather-forecast-container">`;
                        const dailyForecasts = {};

                        data.list.forEach(item => {
                            const date = new Date(item.dt * 1000);
                            const day = date.toLocaleDateString('ko-KR', { weekday: 'short', month: 'numeric', day: 'numeric' });
                            const temp = item.main.temp;
                            const description = item.weather[0].description;
                            const icon = item.weather[0].icon;

                            if (!dailyForecasts[day]) {
                                dailyForecasts[day] = {
                                    temps: [],
                                    descriptions: [],
                                    icons: []
                                };
                            }
                            dailyForecasts[day].temps.push(temp);
                            dailyForecasts[day].descriptions.push(description);
                            dailyForecasts[day].icons.push(icon);
                        });

                        for (const day in dailyForecasts) {
                            const temps = dailyForecasts[day].temps;
                            const avgTemp = (temps.reduce((sum, t) => sum + t, 0) / temps.length).toFixed(1);
                            const mostFrequentDescription = dailyForecasts[day].descriptions.sort((a,b) =>
                                dailyForecasts[day].descriptions.filter(v => v===a).length -
                                dailyForecasts[day].descriptions.filter(v => v===b).length
                            ).pop();
                            const mostFrequentIcon = dailyForecasts[day].icons.sort((a,b) =>
                                dailyForecasts[day].icons.filter(v => v===a).length -
                                dailyForecasts[day].icons.filter(v => v===b).length
                            ).pop();

                            forecastHtml += `
                                <div class="weather-day">
                                    <strong>${day}</strong><br>
                                    <img src="http://openweathermap.org/img/w/${mostFrequentIcon}.png" alt="${mostFrequentDescription}"><br>
                                    ${mostFrequentDescription}<br>
                                    ${avgTemp}°C
                                </div>
                            `;
                        }
                        forecastHtml += `</div>`;
                        weatherInfoDiv.innerHTML = forecastHtml;
                    } else {
                        weatherInfoDiv.innerHTML = `<p>날씨 예보를 불러올 수 없습니다.</p>`;
                    }
                })
                .catch(error => {
                    console.error('날씨 데이터 가져오기 오류:', error);
                    document.getElementById('weather-info').innerHTML = `<p>날씨 예보를 불러오는 중 오류가 발생했습니다.</p>`;
                });
        }

        function initTmap() {
            map = new Tmapv2.Map("map_div", {
                center: new Tmapv2.LatLng(37.5665, 126.9780), // Initial center
                width: "100%",
                height: "100%",
                zoom: 12
            });

            // Call getWeatherAndDisplay with initial map center
            const initialLat = 37.5665; // Seoul Latitude
            const initialLon = 126.9780; // Seoul Longitude
            getWeatherAndDisplay(initialLat, initialLon);

            const seoulStation = {
                lat: 37.5547,
                lon: 126.9704
            };

            navigator.geolocation.getCurrentPosition(
                // Success callback
                position => {
                    userLocation = {
                        lat: position.coords.latitude,
                        lon: position.coords.longitude
                    };
                    map.setCenter(new Tmapv2.LatLng(userLocation.lat, userLocation.lon));
                    new Tmapv2.Marker({
                        position: new Tmapv2.LatLng(userLocation.lat, userLocation.lon),
                        map: map,
                        icon: Tmapv2.asset.Icon.get("b_m_a"), // "http://tmapapi.sktelecom.com/upload/tmap/marker/pin_r_m_s.png",
                        label: '현재 위치'
                    });
                },
                // Error callback
                () => {
                    console.log("현재 위치를 가져올 수 없어 서울역을 기본 위치로 설정합니다.");
                    userLocation = seoulStation;
                    map.setCenter(new Tmapv2.LatLng(userLocation.lat, userLocation.lon));
                    new Tmapv2.Marker({
                        position: new Tmapv2.LatLng(userLocation.lat, userLocation.lon),
                        map: map,
                        icon: Tmapv2.asset.Icon.get("b_m_b"),
                        label: '기본 위치 (서울역)'
                    });
                }
            );
        }

        function clearMap() {
            markers.forEach(marker => marker.setMap(null));
            polylines.forEach(polyline => polyline.setMap(null));
            markers = [];
            polylines = [];
        }

        function drawRoute(endLat, endLon, endName, listItemId) {
            // 기존 경로 삭제
            polylines.forEach(polyline => polyline.setMap(null));
            polylines = [];

            if (!userLocation) {
                alert("현재 위치 정보가 없습니다.");
                return;
            }

            fetch("/get_tmap_route", {
                method: "POST",
                headers: { "content-type": "application/json" },
                body: JSON.stringify({
                    startX: userLocation.lon,
                    startY: userLocation.lat,
                    endX: endLon,
                    endY: endLat,
                    endName: endName
                })
            })
            .then(response => response.json())
            .then(data => {
                console.log(`user location : ${userLocation.lat}, ${userLocation.lon}`);
                
                console.log("TMAP API Response:", JSON.stringify(data, null, 2)); // Log the full API response

                if (data.error) {
                    console.error("TMAP Route Error:", data.error);
                    return;
                }

                if (data.features && data.features.length > 0) {
                    const routeList = document.getElementById("route-list");
                    const waypoints = [];

                    // Remove existing waypoint info
                    const existingWaypoints = routeList.querySelector('.waypoints-info');
                    if (existingWaypoints) {
                        existingWaypoints.remove();
                    }

                    data.features.forEach(feature => {
                        // Collect waypoints
                        /*if (feature.geometry.type === "Point" && feature.properties.pointType === "G") {
                            waypoints.push(feature.properties.name);
                        }*/
                        if (feature.type === "Feature" && [0, 1, 5, 6, 7].includes(feature.properties.roadType)) {
                            waypoints.push(feature.properties.name);
                        }

                        console.log(`waypoints : ${waypoints}`);

                        // Draw route segments with traffic colors
                        if (feature.geometry.type === "LineString") {
                            const coordinates = feature.geometry.coordinates;
                            const trafficData = feature.geometry.traffic;

                            if (trafficData && Array.isArray(trafficData)) {
                                for (let i = 0; i < trafficData.length; i++) {
                                    const trafficInfo = trafficData[i]; // Format: [startIndex, endIndex, congestion, speed]
                                    
                                    if (!Array.isArray(trafficInfo) || trafficInfo.length < 3) {
                                        console.error("Traffic segment data is not in the expected format.", trafficInfo);
                                        continue;
                                    }

                                    const fromNodeIdx = trafficInfo[0];
                                    const toNodeIdx = trafficInfo[1];
                                    const congestion = trafficInfo[2];

                                    const segmentPath = [];
                                    for (let j = fromNodeIdx; j <= toNodeIdx && j < coordinates.length; j++) {
                                        segmentPath.push(new Tmapv2.LatLng(coordinates[j][1], coordinates[j][0]));
                                    }

                                    if (segmentPath.length < 2) continue;

                                    const trafficColors = {
                                        "1": "#009900", // 원활
                                        "2": "#FFD400", // 서행
                                        "3": "#FF8C00", // 지체
                                        "4": "#FF0000"  // 정체
                                    };

                                    let color = trafficColors[congestion] || "#808080"; // Default to Red

                                    const polyline = new Tmapv2.Polyline({
                                        path: segmentPath,
                                        strokeColor: color,
                                        strokeWeight: 8,
                                        map: map
                                    });
                                    polylines.push(polyline);
                                }
                            } else {
                                // Fallback for no traffic data
                                const path = coordinates.map(coord => new Tmapv2.LatLng(coord[1], coord[0]));
                                const polyline = new Tmapv2.Polyline({
                                    path: path,
                                    strokeColor: "#808080",
                                    strokeWeight: 6,
                                    map: map
                                });
                                polylines.push(polyline);
                            }
                        }
                    });

                    // Update the main list item with total distance/time
                    const listItem = document.getElementById(listItemId);
                    const properties = data.features[0].properties;
                    if (listItem && properties) {
                        const timeInMinutes = Math.round(properties.totalTime / 60);
                        const toll = properties.totalFare.toLocaleString('ko-KR');
                        const distanceInKm = (properties.totalDistance / 1000).toFixed(1);

                        //let waypointsHTML = '';
                        //if (waypoints.length > 0) {
                        //    waypointsHTML = `경유지: ${waypoints.join(" &rarr; ")}<br>`;
                        //}

                        listItem.innerHTML = `
                            <strong>${endName}</strong><br>
                            ${waypointsHTML}
                            거리: ${distanceInKm}km, 시간: 약 ${timeInMinutes}분, 통행료: ${toll}원
                        `;
                    }
                }
                
                // Update weather for the selected location
                getWeatherAndDisplay(endLat, endLon);
            })
            .catch(error => console.error('Error fetching TMAP route:', error));
        }

        window.onload = initTmap;
    </script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const initialMessage = {{ initial_message|tojson|safe }};
            if (initialMessage) {
                const chatInput = document.getElementById('chat-input');
                chatInput.value = initialMessage;
                sendMessage();
            }
        });
    </script>
</body>
</html>
