<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TrailMate - 채팅</title>
    <link rel="stylesheet" href="/static/base.css">
    <link rel="stylesheet" href="/static/chat.css">
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://apis.openapi.sk.com/tmap/jsv2?version=1&appKey={{ tmap_api_key }}"></script>
    <style>
        #map-and-list-container {
            display: none;
        }

        /* Dark Mode Toggle Switch */
        .dark-mode-toggle {
            position: absolute;
            top: 20px;
            right: 20px;
        }

        .dark-mode-toggle input[type="checkbox"] {
            display: none;
        }

        .dark-mode-toggle label {
            cursor: pointer;
            display: inline-block;
            width: 50px;
            height: 25px;
            background-color: #40444B;
            border-radius: 25px;
            position: relative;
            transition: background-color 0.3s;
        }

        .dark-mode-toggle label::after {
            content: '';
            position: absolute;
            width: 21px;
            height: 21px;
            border-radius: 50%;
            background-color: white;
            top: 2px;
            left: 2px;
            transition: transform 0.3s;
        }

        .dark-mode-toggle input[type="checkbox"]:checked + label {
            background-color: #5865F2;
        }

        .dark-mode-toggle input[type="checkbox"]:checked + label::after {
            transform: translateX(25px);
        }

        /* Dark & Light Mode Theme */
        body.dark-mode {
            background-color: #313338;
            color: #ffffff;
        }

        body:not(.dark-mode) {
            background-color: #ffffff;
            color: #000000;
        }

        .dark-mode .sidebar { background-color: #2B2D31; border-right-color: #2A2B2F; }
        .dark-mode .sidebar-header .back-to-home-btn { background-color: #40444B; color: white; }
        .dark-mode .sidebar-content p { color: #B9BBBE; }
        .dark-mode .sidebar-content a { color: #B9BBBE; }
        .dark-mode .sidebar-content a:hover { background-color: #383A40; color: #ffffff; }
        .dark-mode .sidebar-footer { border-top-color: #2A2B2F; }
        .dark-mode .sidebar-footer a { color: #B9BBBE; }
        .dark-mode .chat-area { background-color: #313338; }
        .dark-mode .chat-header { border-bottom-color: #2A2B2F; }
        .dark-mode .chat-header h2 { color: #ffffff; }
        .dark-mode .chat-header p { color: #B9BBBE; }
        .dark-mode .message.bot { background-color: #383A40; color: #EAEAEA; }
        .dark-mode .message.user { background-color: #5865F2; color: white; }
        .dark-mode .chat-footer { border-top-color: #2A2B2F; }
        .dark-mode .chat-input-form input { background-color: #40444B; color: white; }
        .dark-mode .map-and-list-container { border-left-color: #2A2B2F; }
        .dark-mode .map-container { background-color: #2B2D31; }
        .dark-mode #weather-info { background-color: #2B2D31; border-bottom-color: #2A2B2F; color: #B9BBBE; }
        .dark-mode #route-list-container { background-color: #2B2D31; }
        .dark-mode #route-list li { background-color: #383A40; color: #EAEAEA; }
        .dark-mode #route-list li:hover { background-color: #40444B; }
        .dark-mode .weather-day { background-color: #383A40; }


        body:not(.dark-mode) .sidebar { background-color: #F2F3F5; border-right-color: #E0E0E0; }
        body:not(.dark-mode) .sidebar-header .back-to-home-btn { background-color: #E9EAED; color: #000; }
        body:not(.dark-mode) .sidebar-content p { color: #4F5660; }
        body:not(.dark-mode) .sidebar-content a { color: #4F5660; }
        body:not(.dark-mode) .sidebar-content a:hover { background-color: #E0E0E0; color: #000; }
        body:not(.dark-mode) .sidebar-footer { border-top-color: #E0E0E0; }
        body:not(.dark-mode) .sidebar-footer a { color: #4F5660; }
        body:not(.dark-mode) .chat-area { background-color: #FFFFFF; }
        body:not(.dark-mode) .chat-header { border-bottom-color: #E0E0E0; }
        body:not(.dark-mode) .chat-header h2 { color: #000000; }
        body:not(.dark-mode) .chat-header p { color: #4F5660; }
        body:not(.dark-mode) .message.bot { background-color: #F2F3F5; color: #000000; }
        body:not(.dark-mode) .message.user { background-color: #5865F2; color: white; }
        body:not(.dark-mode) .chat-footer { border-top-color: #E0E0E0; }
        body:not(.dark-mode) .chat-input-form input { background-color: #E9EAED; color: #000; }
        body:not(.dark-mode) .map-and-list-container { border-left-color: #E0E0E0; }
        body:not(.dark-mode) .map-container { background-color: #F2F3F5; }
        body:not(.dark-mode) #weather-info { background-color: #F2F3F5; border-bottom-color: #E0E0E0; color: #4F5660; }
        body:not(.dark-mode) #route-list-container { background-color: #F2F3F5; }
        body:not(.dark-mode) #route-list li { background-color: #E9EAED; color: #000000; }
        body:not(.dark-mode) #route-list li:hover { background-color: #E0E0E0; }
        body:not(.dark-mode) .weather-day { background-color: #E9EAED; }
    </style>
</head>
<body>
    <div class="chat-container">
        <aside class="sidebar">
            <div class="sidebar-header">
                <button class="new-chat-btn">+ 새 대화 시작</button>
                <button onclick='location.href="/"' class="back-to-home-btn">홈으로 돌아가기</button>
            </div>
            <div class="sidebar-content">
                <p>최근대화</p>
            </div>
            <div class="sidebar-footer">
                <a href="#">설정</a>
                <a href="#">도움말</a>
            </div>
        </aside>

        <main class="chat-area">
            <header class="chat-header">
                <h2><img src="/static/camptory.png" width="25px" height="30px"> 캠토리</h2>
                <p>캠핑 전문가 AI 어시스턴트</p>
                <div class="dark-mode-toggle">
                    <input type="checkbox" id="dark-mode-switch"/>
                    <label for="dark-mode-switch"></label>
                </div>
            </header>
            <div id="weather-info"></div>
            <div class="messages">
                <div class="message bot">
                    <p>안녕하세요! 저는 캠토리입니다. <br><br>
캠핑에 관한 모든 질문에 답해드릴게요! 캠핑 장소 추천, 장비 선택, 요리 레시피, 안전 수칙 등 무엇이든 편하게 물어보세요.
<br><br>
어떤 도움이 필요하신가요? 😊</p>
                </div>
            </div>
            <footer class="chat-footer">
                <form id="chat-form" class="chat-input-form">
                    <input type="text" id="chat-input" placeholder="궁금한 점을 물어보세요...">
                    <button type="submit">전송</button>
                </form>
            </footer>
        </main>

        <aside id="map-and-list-container" class="map-and-list-container">
            <div class="map-container">
                <div id="map_div" style="color: black; width: 100%; height: 400px;"></div>
            </div>
            <div id="route-list-container">
                <ul id="route-list"></ul>
            </div>
        </aside>
    </div>

    <script src="/static/script.js"></script>
    <script>
        let userLocation;
        let map;
        let markers = [];
        let polylines = [];
        let recommendedLocations = []; // 추천 장소 목록 저장

        function getWeatherAndDisplay(lat, lon) {
            const apiKey = '{{ openweathermap_api_key }}'; // Loaded from .env via Flask
            const weatherUrl = `https://api.openweathermap.org/data/2.5/forecast?lat=${lat}&lon=${lon}&appid=${apiKey}&units=metric&lang=kr`;

            fetch(weatherUrl)
                .then(response => response.json())
                .then(data => {
                    const weatherInfoDiv = document.getElementById('weather-info');
                    if (data.list && data.list.length > 0) {
                        let forecastHtml = `<h3>${data["city"]["name"]} 날씨 예보</h3><div class="weather-forecast-container">`;
                        const dailyForecasts = {};

                        data.list.forEach(item => {
                            const date = new Date(item.dt * 1000);
                            const day = date.toLocaleDateString('ko-KR', { weekday: 'short', month: 'numeric', day: 'numeric' });
                            const temp = item.main.temp;
                            const description = item.weather[0].description;
                            const icon = item.weather[0].icon;

                            if (!dailyForecasts[day]) {
                                dailyForecasts[day] = {
                                    temps: [],
                                    descriptions: [],
                                    icons: []
                                };
                            }
                            dailyForecasts[day].temps.push(temp);
                            dailyForecasts[day].descriptions.push(description);
                            dailyForecasts[day].icons.push(icon);
                        });

                        for (const day in dailyForecasts) {
                            const temps = dailyForecasts[day].temps;
                            const avgTemp = (temps.reduce((sum, t) => sum + t, 0) / temps.length).toFixed(1);
                            const mostFrequentDescription = dailyForecasts[day].descriptions.sort((a,b) =>
                                dailyForecasts[day].descriptions.filter(v => v===a).length -
                                dailyForecasts[day].descriptions.filter(v => v===b).length
                            ).pop();
                            const mostFrequentIcon = dailyForecasts[day].icons.sort((a,b) =>
                                dailyForecasts[day].icons.filter(v => v===a).length -
                                dailyForecasts[day].icons.filter(v => v===b).length
                            ).pop();

                            forecastHtml += `
                                <div class="weather-day">
                                    <strong>${day}</strong><br>
                                    <img src="http://openweathermap.org/img/w/${mostFrequentIcon}.png" alt="${mostFrequentDescription}"><br>
                                    ${mostFrequentDescription}<br>
                                    ${avgTemp}°C
                                </div>
                            `;
                        }
                        forecastHtml += `</div>`;
                        weatherInfoDiv.innerHTML = forecastHtml;
                    } else {
                        weatherInfoDiv.innerHTML = `<p>날씨 예보를 불러올 수 없습니다.</p>`;
                    }
                })
                .catch(error => {
                    console.error('날씨 데이터 가져오기 오류:', error);
                    document.getElementById('weather-info').innerHTML = `<p>날씨 예보를 불러오는 중 오류가 발생했습니다.</p>`;
                });
        }

        function initTmap() {
            map = new Tmapv2.Map("map_div", {
                center: new Tmapv2.LatLng(37.5665, 126.9780), // Initial center
                width: "100%",
                height: "100%",
                zoom: 12
            });

            // Call getWeatherAndDisplay with initial map center
            const initialLat = 37.5665; // Seoul Latitude
            const initialLon = 126.9780; // Seoul Longitude
            getWeatherAndDisplay(initialLat, initialLon);

            const seoulStation = {
                lat: 37.5547,
                lon: 126.9704
            };

            navigator.geolocation.getCurrentPosition(
                // Success callback
                position => {
                    userLocation = {
                        lat: position.coords.latitude,
                        lon: position.coords.longitude
                    };
                    map.setCenter(new Tmapv2.LatLng(userLocation.lat, userLocation.lon));
                    new Tmapv2.Marker({
                        position: new Tmapv2.LatLng(userLocation.lat, userLocation.lon),
                        map: map,
                        icon: Tmapv2.asset.Icon.get("b_m_a"), // "http://tmapapi.sktelecom.com/upload/tmap/marker/pin_r_m_s.png",
                        label: '현재 위치'
                    });
                },
                // Error callback
                () => {
                    console.log("현재 위치를 가져올 수 없어 서울역을 기본 위치로 설정합니다.");
                    userLocation = seoulStation;
                    map.setCenter(new Tmapv2.LatLng(userLocation.lat, userLocation.lon));
                    new Tmapv2.Marker({
                        position: new Tmapv2.LatLng(userLocation.lat, userLocation.lon),
                        map: map,
                        icon: Tmapv2.asset.Icon.get("b_m_b"),
                        label: '기본 위치 (서울역)'
                    });
                }
            );
        }

        function clearMap() {
            markers.forEach(marker => marker.setMap(null));
            polylines.forEach(polyline => polyline.setMap(null));
            markers = [];
            polylines = [];
        }

        function drawRoute(endLat, endLon, endName, listItemId) {
            // 기존 경로 삭제
            polylines.forEach(polyline => polyline.setMap(null));
            polylines = [];

            // Update weather for the selected location immediately
            getWeatherAndDisplay(endLat, endLon);

            if (!userLocation) {
                alert("현재 위치 정보가 없습니다. 경로를 표시할 수 없습니다.");
                return;
            }

            fetch("/get_tmap_route", {
                method: "POST",
                headers: { "content-type": "application/json" },
                body: JSON.stringify({
                    startX: userLocation.lon,
                    startY: userLocation.lat,
                    endX: endLon,
                    endY: endLat,
                    endName: endName
                })
            })
            .then(response => response.json())
            .then(data => {
                console.log(`user location : ${userLocation.lat}, ${userLocation.lon}`);
                
                console.log("TMAP API Response:", JSON.stringify(data, null, 2)); // Log the full API response

                if (data.error) {
                    console.error("TMAP Route Error:", data.error);
                    return;
                }

                if (data.features && data.features.length > 0) {
                    const routeList = document.getElementById("route-list");
                    const waypoints = [];

                    // Remove existing waypoint info
                    const existingWaypoints = routeList.querySelector('.waypoints-info');
                    if (existingWaypoints) {
                        existingWaypoints.remove();
                    }

                    data.features.forEach(feature => {
                        // Collect waypoints
                        /*if (feature.geometry.type === "Point" && feature.properties.pointType === "G") {
                            waypoints.push(feature.properties.name);
                        }*/
                        if (feature.type === "Feature" && [0, 1, 5, 6, 7].includes(feature.properties.roadType)) {
                            waypoints.push(feature.properties.name);
                        }

                        console.log(`waypoints : ${waypoints}`);

                        // Draw route segments with traffic colors
                        if (feature.geometry.type === "LineString") {
                            const coordinates = feature.geometry.coordinates;
                            const trafficData = feature.geometry.traffic;

                            if (trafficData && Array.isArray(trafficData)) {
                                for (let i = 0; i < trafficData.length; i++) {
                                    const trafficInfo = trafficData[i]; // Format: [startIndex, endIndex, congestion, speed]
                                    
                                    if (!Array.isArray(trafficInfo) || trafficInfo.length < 3) {
                                        console.error("Traffic segment data is not in the expected format.", trafficInfo);
                                        continue;
                                    }

                                    const fromNodeIdx = trafficInfo[0];
                                    const toNodeIdx = trafficInfo[1];
                                    const congestion = trafficInfo[2];

                                    const segmentPath = [];
                                    for (let j = fromNodeIdx; j <= toNodeIdx && j < coordinates.length; j++) {
                                        segmentPath.push(new Tmapv2.LatLng(coordinates[j][1], coordinates[j][0]));
                                    }

                                    if (segmentPath.length < 2) continue;

                                    const trafficColors = {
                                        "1": "#009900", // 원활
                                        "2": "#FFD400", // 서행
                                        "3": "#FF8C00", // 지체
                                        "4": "#FF0000"  // 정체
                                    };

                                    let color = trafficColors[congestion] || "#808080"; // Default to Red

                                    const polyline = new Tmapv2.Polyline({
                                        path: segmentPath,
                                        strokeColor: color,
                                        strokeWeight: 8,
                                        map: map
                                    });
                                    polylines.push(polyline);
                                }
                            } else {
                                // Fallback for no traffic data
                                const path = coordinates.map(coord => new Tmapv2.LatLng(coord[1], coord[0]));
                                const polyline = new Tmapv2.Polyline({
                                    path: path,
                                    strokeColor: "#808080",
                                    strokeWeight: 6,
                                    map: map
                                });
                                polylines.push(polyline);
                            }
                        }
                    });

                    // Update the main list item with total distance/time
                    const listItem = document.getElementById(listItemId);
                    const properties = data.features[0].properties;
                    if (listItem && properties) {
                        const timeInMinutes = Math.round(properties.totalTime / 60);
                        const toll = properties.totalFare.toLocaleString('ko-KR');
                        const distanceInKm = (properties.totalDistance / 1000).toFixed(1);

                        //let waypointsHTML = '';
                        //if (waypoints.length > 0) {
                        //    waypointsHTML = `경유지: ${waypoints.join(" &rarr; ")}<br>`;
                        //}

                        listItem.innerHTML = `
                            <strong>${endName}</strong><br>
                            ${waypointsHTML}
                            거리: ${distanceInKm}km, 시간: 약 ${timeInMinutes}분, 통행료: ${toll}원
                        `;
                    }
                }
                
                // Update weather for the selected location
                
            })
            .catch(error => console.error('Error fetching TMAP route:', error));
        }

        window.onload = initTmap;
    </script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const initialMessage = {{ initial_message|tojson|safe }};
            if (initialMessage) {
                const chatInput = document.getElementById('chat-input');
                chatInput.value = initialMessage;
                sendMessage();
            }
        });

        const darkModeSwitch = document.getElementById('dark-mode-switch');
        const body = document.body;

        // Check for saved dark mode preference
        if (localStorage.getItem('darkMode') === 'enabled') {
            body.classList.add('dark-mode');
            darkModeSwitch.checked = true;
        } else {
            // By default, enable dark mode if no preference is set
            body.classList.add('dark-mode');
            darkModeSwitch.checked = true;
            localStorage.setItem('darkMode', 'enabled');
        }

        darkModeSwitch.addEventListener('change', () => {
            if (darkModeSwitch.checked) {
                body.classList.add('dark-mode');
                localStorage.setItem('darkMode', 'enabled');
            } else {
                body.classList.remove('dark-mode');
                localStorage.setItem('darkMode', 'disabled');
            }
        });
    </script>
</body>
</html>
