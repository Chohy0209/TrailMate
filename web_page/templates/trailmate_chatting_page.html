<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TrailMate - ì±„íŒ…</title>
    <link rel="stylesheet" href="/static/base.css">
    <link rel="stylesheet" href="/static/chat.css">
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://apis.openapi.sk.com/tmap/jsv2?version=1&appKey={{ tmap_api_key }}"></script>
</head>
<body>
    <div class="chat-container">
        <aside class="sidebar">
            <div class="sidebar-header">
                <button class="new-chat-btn">+ ìƒˆ ëŒ€í™” ì‹œì‘</button>
                <button onclick='location.href="/"' class="back-to-home-btn">í™ˆìœ¼ë¡œ ëŒì•„ê°€ê¸°</button>
            </div>
            <div class="sidebar-content">
                <p>ìµœê·¼ëŒ€í™”</p>
            </div>
            <div class="sidebar-footer">
                <a href="#">ì„¤ì •</a>
                <a href="#">ë„ì›€ë§</a>
            </div>
        </aside>

        <main class="chat-area">
            <header class="chat-header">
                <h2><img src="/static/squirrel.png" width="30px" height="30px"> ìº í† ë¦¬</h2>
                <p>ìº í•‘ ì „ë¬¸ê°€ AI ì–´ì‹œìŠ¤í„´íŠ¸</p>
            </header>
            <div id="weather-info"></div>
            <div class="messages">
                <div class="message bot">
                    <p>ì•ˆë…•í•˜ì„¸ìš”! ì €ëŠ” ìº í† ë¦¬ì…ë‹ˆë‹¤. ìº í•‘ì— ê´€í•œ ëª¨ë“  ì§ˆë¬¸ì— ë‹µí•´ë“œë¦´ê²Œìš”! ì–´ë–¤ ë„ì›€ì´ í•„ìš”í•˜ì‹ ê°€ìš”? ğŸ˜Š</p>
                </div>
            </div>
            <footer class="chat-footer">
                <form id="chat-form" class="chat-input-form">
                    <input type="text" id="chat-input" placeholder="ê¶ê¸ˆí•œ ì ì„ ë¬¼ì–´ë³´ì„¸ìš”...">
                    <button type="submit">ì „ì†¡</button>
                </form>
            </footer>
        </main>

        <aside class="map-and-list-container">
            <div class="map-container">
                <div id="map_div" style="width: 100%; height: 400px;"></div>
            </div>
            <div id="route-list-container">
                <ul id="route-list"></ul>
            </div>
        </aside>
    </div>

    <script src="/static/script.js"></script>
    <script>
        let userLocation;
        let map;
        let markers = [];
        let polylines = [];
        let recommendedLocations = []; // ì¶”ì²œ ì¥ì†Œ ëª©ë¡ ì €ì¥

        function getWeatherAndDisplay(lat, lon) {
            const apiKey = '{{ openweathermap_api_key }}'; // Loaded from .env via Flask
            const weatherUrl = `https://api.openweathermap.org/data/2.5/forecast?lat=${lat}&lon=${lon}&appid=${apiKey}&units=metric&lang=kr`;

            fetch(weatherUrl)
                .then(response => response.json())
                .then(data => {
                    const weatherInfoDiv = document.getElementById('weather-info');
                    if (data.list && data.list.length > 0) {
                        let forecastHtml = `<h3>${data["city"]["name"]} ë‚ ì”¨ ì˜ˆë³´</h3><div class="weather-forecast-container">`;
                        const dailyForecasts = {};

                        data.list.forEach(item => {
                            const date = new Date(item.dt * 1000);
                            const day = date.toLocaleDateString('ko-KR', { weekday: 'short', month: 'numeric', day: 'numeric' });
                            const temp = item.main.temp;
                            const description = item.weather[0].description;
                            const icon = item.weather[0].icon;

                            if (!dailyForecasts[day]) {
                                dailyForecasts[day] = {
                                    temps: [],
                                    descriptions: [],
                                    icons: []
                                };
                            }
                            dailyForecasts[day].temps.push(temp);
                            dailyForecasts[day].descriptions.push(description);
                            dailyForecasts[day].icons.push(icon);
                        });

                        for (const day in dailyForecasts) {
                            const temps = dailyForecasts[day].temps;
                            const avgTemp = (temps.reduce((sum, t) => sum + t, 0) / temps.length).toFixed(1);
                            const mostFrequentDescription = dailyForecasts[day].descriptions.sort((a,b) =>
                                dailyForecasts[day].descriptions.filter(v => v===a).length -
                                dailyForecasts[day].descriptions.filter(v => v===b).length
                            ).pop();
                            const mostFrequentIcon = dailyForecasts[day].icons.sort((a,b) =>
                                dailyForecasts[day].icons.filter(v => v===a).length -
                                dailyForecasts[day].icons.filter(v => v===b).length
                            ).pop();

                            forecastHtml += `
                                <div class="weather-day">
                                    <strong>${day}</strong><br>
                                    <img src="http://openweathermap.org/img/w/${mostFrequentIcon}.png" alt="${mostFrequentDescription}"><br>
                                    ${mostFrequentDescription}<br>
                                    ${avgTemp}Â°C
                                </div>
                            `;
                        }
                        forecastHtml += `</div>`;
                        weatherInfoDiv.innerHTML = forecastHtml;
                    } else {
                        weatherInfoDiv.innerHTML = `<p>ë‚ ì”¨ ì˜ˆë³´ë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.</p>`;
                    }
                })
                .catch(error => {
                    console.error('ë‚ ì”¨ ë°ì´í„° ê°€ì ¸ì˜¤ê¸° ì˜¤ë¥˜:', error);
                    document.getElementById('weather-info').innerHTML = `<p>ë‚ ì”¨ ì˜ˆë³´ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.</p>`;
                });
        }

        function initTmap() {
            map = new Tmapv2.Map("map_div", {
                center: new Tmapv2.LatLng(37.5665, 126.9780), // Initial center
                width: "100%",
                height: "100%",
                zoom: 12
            });

            // Call getWeatherAndDisplay with initial map center
            const initialLat = 37.5665; // Seoul Latitude
            const initialLon = 126.9780; // Seoul Longitude
            getWeatherAndDisplay(initialLat, initialLon);

            const seoulStation = {
                lat: 37.5547,
                lon: 126.9704
            };

            navigator.geolocation.getCurrentPosition(
                // Success callback
                position => {
                    userLocation = {
                        lat: position.coords.latitude,
                        lon: position.coords.longitude
                    };
                    map.setCenter(new Tmapv2.LatLng(userLocation.lat, userLocation.lon));
                    new Tmapv2.Marker({
                        position: new Tmapv2.LatLng(userLocation.lat, userLocation.lon),
                        map: map,
                        icon: Tmapv2.asset.Icon.get("b_m_a"), // "http://tmapapi.sktelecom.com/upload/tmap/marker/pin_r_m_s.png",
                        label: 'í˜„ì¬ ìœ„ì¹˜'
                    });
                },
                // Error callback
                () => {
                    console.log("í˜„ì¬ ìœ„ì¹˜ë¥¼ ê°€ì ¸ì˜¬ ìˆ˜ ì—†ì–´ ì„œìš¸ì—­ì„ ê¸°ë³¸ ìœ„ì¹˜ë¡œ ì„¤ì •í•©ë‹ˆë‹¤.");
                    userLocation = seoulStation;
                    map.setCenter(new Tmapv2.LatLng(userLocation.lat, userLocation.lon));
                    new Tmapv2.Marker({
                        position: new Tmapv2.LatLng(userLocation.lat, userLocation.lon),
                        map: map,
                        icon: Tmapv2.asset.Icon.get("b_m_b"),
                        label: 'ê¸°ë³¸ ìœ„ì¹˜ (ì„œìš¸ì—­)'
                    });
                }
            );
        }

        function clearMap() {
            markers.forEach(marker => marker.setMap(null));
            polylines.forEach(polyline => polyline.setMap(null));
            markers = [];
            polylines = [];
        }

        function drawRoute(endLat, endLon, endName, listItemId) {
            // ê¸°ì¡´ ê²½ë¡œ ì‚­ì œ
            polylines.forEach(polyline => polyline.setMap(null));
            polylines = [];

            if (!userLocation) {
                alert("í˜„ì¬ ìœ„ì¹˜ ì •ë³´ê°€ ì—†ìŠµë‹ˆë‹¤.");
                return;
            }

            fetch("/get_tmap_route", {
                method: "POST",
                headers: { "content-type": "application/json" },
                body: JSON.stringify({
                    startX: userLocation.lon,
                    startY: userLocation.lat,
                    endX: endLon,
                    endY: endLat,
                    endName: endName
                })
            })
            .then(response => response.json())
            .then(data => {
                console.log(`user location : ${userLocation.lat}, ${userLocation.lon}`);
                
                console.log("TMAP API Response:", JSON.stringify(data, null, 2)); // Log the full API response

                if (data.error) {
                    console.error("TMAP Route Error:", data.error);
                    return;
                }

                if (data.features && data.features.length > 0) {
                    const routeList = document.getElementById("route-list");
                    const waypoints = [];

                    // Remove existing waypoint info
                    const existingWaypoints = routeList.querySelector('.waypoints-info');
                    if (existingWaypoints) {
                        existingWaypoints.remove();
                    }

                    data.features.forEach(feature => {
                        // Collect waypoints
                        /*if (feature.geometry.type === "Point" && feature.properties.pointType === "G") {
                            waypoints.push(feature.properties.name);
                        }*/
                        if (feature.type === "Feature" && [0, 1, 5, 6, 7].includes(feature.properties.roadType)) {
                            waypoints.push(feature.properties.name);
                        }

                        console.log(`waypoints : ${waypoints}`);

                        // Draw route segments with traffic colors
                        if (feature.geometry.type === "LineString") {
                            const coordinates = feature.geometry.coordinates;
                            const trafficData = feature.geometry.traffic;

                            if (trafficData && Array.isArray(trafficData)) {
                                for (let i = 0; i < trafficData.length; i++) {
                                    const trafficInfo = trafficData[i]; // Format: [startIndex, endIndex, congestion, speed]
                                    
                                    if (!Array.isArray(trafficInfo) || trafficInfo.length < 3) {
                                        console.error("Traffic segment data is not in the expected format.", trafficInfo);
                                        continue;
                                    }

                                    const fromNodeIdx = trafficInfo[0];
                                    const toNodeIdx = trafficInfo[1];
                                    const congestion = trafficInfo[2];

                                    const segmentPath = [];
                                    for (let j = fromNodeIdx; j <= toNodeIdx && j < coordinates.length; j++) {
                                        segmentPath.push(new Tmapv2.LatLng(coordinates[j][1], coordinates[j][0]));
                                    }

                                    if (segmentPath.length < 2) continue;

                                    const trafficColors = {
                                        "1": "#009900", // ì›í™œ
                                        "2": "#FFD400", // ì„œí–‰
                                        "3": "#FF8C00", // ì§€ì²´
                                        "4": "#FF0000"  // ì •ì²´
                                    };

                                    let color = trafficColors[congestion] || "#808080"; // Default to Red

                                    const polyline = new Tmapv2.Polyline({
                                        path: segmentPath,
                                        strokeColor: color,
                                        strokeWeight: 8,
                                        map: map
                                    });
                                    polylines.push(polyline);
                                }
                            } else {
                                // Fallback for no traffic data
                                const path = coordinates.map(coord => new Tmapv2.LatLng(coord[1], coord[0]));
                                const polyline = new Tmapv2.Polyline({
                                    path: path,
                                    strokeColor: "#808080",
                                    strokeWeight: 6,
                                    map: map
                                });
                                polylines.push(polyline);
                            }
                        }
                    });

                    // Update the main list item with total distance/time
                    const listItem = document.getElementById(listItemId);
                    const properties = data.features[0].properties;
                    if (listItem && properties) {
                        const timeInMinutes = Math.round(properties.totalTime / 60);
                        const toll = properties.totalFare.toLocaleString('ko-KR');
                        const distanceInKm = (properties.totalDistance / 1000).toFixed(1);

                        //let waypointsHTML = '';
                        //if (waypoints.length > 0) {
                        //    waypointsHTML = `ê²½ìœ ì§€: ${waypoints.join(" &rarr; ")}<br>`;
                        //}

                        listItem.innerHTML = `
                            <strong>${endName}</strong><br>
                            ${waypointsHTML}
                            ê±°ë¦¬: ${distanceInKm}km, ì‹œê°„: ì•½ ${timeInMinutes}ë¶„, í†µí–‰ë£Œ: ${toll}ì›
                        `;
                    }
                }
                
                // Update weather for the selected location
                getWeatherAndDisplay(endLat, endLon);
            })
            .catch(error => console.error('Error fetching TMAP route:', error));
        }

        window.onload = initTmap;
    </script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const initialMessage = {{ initial_message|tojson|safe }};
            if (initialMessage) {
                const chatInput = document.getElementById('chat-input');
                chatInput.value = initialMessage;
                sendMessage();
            }
        });
    </script>
</body>
</html>
